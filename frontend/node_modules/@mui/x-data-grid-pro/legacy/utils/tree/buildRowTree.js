import _extends from "@babel/runtime/helpers/esm/extends";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";

/**
 * Transform a list of rows into a tree structure where each row references its parent and children.
 * If a row have a parent which does not exist in the input rows, creates an auto generated row
 *
 ```
 params = {
   ids: [0, 1, 2],
   idRowsLookup: { 0: {...}, 1: {...}, 2: {...} },
   rows: [
     { id: 0, path: ['A'] },
     { id: 1, path: ['B', 'A'] },
     { id: 2, path: ['B', 'A', 'A'] }
   ],
   defaultGroupingExpansionDepth: 0,
 }
 Returns:
 {
   ids: [0, 1, 2, 'auto-generated-row-B'],
   idRowsLookup: { 0: {...}, 1: {...}, 2: {...}, 'auto-generated-row-B': {} },
   tree: {
     '0': { id: 0, parent: null, childrenExpanded: false, depth: 0, groupingKey: 'A' },
     'auto-generated-row-B': { id: 'auto-generated-row-B', parent: null, childrenExpanded: false, depth: 0, groupingKey: 'B' },
     '1': { id: 1, parent: 'auto-generated-row-B', childrenExpanded: false, depth: 1, groupingKey: 'A' },
     '2': { id: 2, parent: 1, childrenExpanded: false, depth: 2, groupingKey: 'A' },
   },
   treeDepth: 3,
 }
 ```
 */
export var buildRowTree = function buildRowTree(params) {
  // During the build, we store the children as a Record to avoid linear complexity when checking if a children is already defined.
  var tempTree = {};
  var treeDepth = 1;

  var ids = _toConsumableArray(params.ids);

  var idRowsLookup = _extends({}, params.idRowsLookup);

  var groupingCriteriaToIdTree = {};

  var isGroupExpandedByDefault = function isGroupExpandedByDefault(node) {
    var _params$previousTree, _params$previousTree$;

    var previousExpansion = (_params$previousTree = params.previousTree) == null ? void 0 : (_params$previousTree$ = _params$previousTree[node.id]) == null ? void 0 : _params$previousTree$.childrenExpanded;

    if (previousExpansion != null) {
      return previousExpansion;
    }

    if (!node.children || !node.children.length) {
      return undefined;
    }

    if (params.isGroupExpandedByDefault) {
      return params.isGroupExpandedByDefault(node);
    }

    return params.defaultGroupingExpansionDepth === -1 || params.defaultGroupingExpansionDepth > node.depth;
  };

  for (var i = 0; i < params.rows.length; i += 1) {
    var row = params.rows[i];
    var keyToIdSubTree = groupingCriteriaToIdTree;
    var parentNode = null;

    for (var depth = 0; depth < row.path.length; depth += 1) {
      var _row$path$depth = row.path[depth],
          _key = _row$path$depth.key,
          rawField = _row$path$depth.field;

      var _field = rawField != null ? rawField : '__no_field__';

      var nodeId = void 0;
      var fieldSubTree = keyToIdSubTree[_field];

      if (!fieldSubTree) {
        fieldSubTree = {};
        keyToIdSubTree[_field] = fieldSubTree;
      }

      var keyConfig = fieldSubTree[_key.toString()];

      if (keyConfig) {
        if (depth === row.path.length - 1) {
          var _params$onDuplicatePa;

          (_params$onDuplicatePa = params.onDuplicatePath) == null ? void 0 : _params$onDuplicatePa.call(params, keyConfig.id, row.id, row.path);
        }

        nodeId = keyConfig.id;
      } else {
        if (depth === row.path.length - 1) {
          nodeId = row.id;
        } else {
          nodeId = "auto-generated-row-".concat(row.path.map(function (groupingCriteria) {
            return "".concat(groupingCriteria.field, "/").concat(groupingCriteria.key);
          }).slice(0, depth + 1).join('-'));
        }

        keyConfig = {
          id: nodeId,
          children: {}
        };
        fieldSubTree[_key.toString()] = keyConfig;
      }

      keyToIdSubTree = keyConfig.children;

      if (!tempTree[nodeId]) {
        var _parentNode$id, _parentNode;

        var isAutoGenerated = depth < row.path.length - 1;
        var _node = {
          id: nodeId,
          isAutoGenerated: isAutoGenerated,
          parent: (_parentNode$id = (_parentNode = parentNode) == null ? void 0 : _parentNode.id) != null ? _parentNode$id : null,
          groupingKey: _key,
          groupingField: rawField,
          depth: depth
        };

        if (isAutoGenerated) {
          idRowsLookup[nodeId] = {};
          ids.push(nodeId);
        }

        tempTree[nodeId] = _node;
      }

      if (parentNode != null) {
        if (!parentNode.children) {
          parentNode.children = {};
        }

        parentNode.children[nodeId] = nodeId;
      }

      parentNode = tempTree[nodeId];
    }

    treeDepth = Math.max(treeDepth, row.path.length);
  }

  var tree = {};

  var _loop = function _loop(_i) {
    var _params$previousTree2, _previousNode$childre, _node$children, _previousNode$childre2;

    var rowId = ids[_i];
    var tempNode = tempTree[rowId];

    var nodeWithoutChildrenExpansion = _extends({}, tempNode, {
      children: tempNode.children ? Object.values(tempNode.children) : undefined
    });

    var node = _extends({}, nodeWithoutChildrenExpansion, {
      childrenExpanded: isGroupExpandedByDefault(nodeWithoutChildrenExpansion)
    });

    var previousNode = (_params$previousTree2 = params.previousTree) == null ? void 0 : _params$previousTree2[node.id];
    var shouldReUsePreviousNode = previousNode && previousNode.isAutoGenerated === node.isAutoGenerated && previousNode.parent === node.parent && previousNode.groupingKey === node.groupingKey && previousNode.groupingField === node.groupingField && previousNode.depth === node.depth && previousNode.childrenExpanded === node.childrenExpanded && ((_previousNode$childre = previousNode.children) == null ? void 0 : _previousNode$childre.length) === ((_node$children = node.children) == null ? void 0 : _node$children.length) && ((_previousNode$childre2 = previousNode.children) == null ? void 0 : _previousNode$childre2.every(function (childId, index) {
      var _node$children2;

      return ((_node$children2 = node.children) == null ? void 0 : _node$children2[index]) === childId;
    }));

    if (shouldReUsePreviousNode) {
      tree[rowId] = previousNode;
    } else {
      tree[rowId] = node;
    }
  };

  for (var _i = 0; _i < ids.length; _i += 1) {
    _loop(_i);
  }

  return {
    tree: tree,
    treeDepth: treeDepth,
    ids: ids,
    idRowsLookup: idRowsLookup,
    groupingName: params.groupingName
  };
};