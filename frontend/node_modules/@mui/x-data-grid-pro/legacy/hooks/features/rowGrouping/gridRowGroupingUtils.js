import _extends from "@babel/runtime/helpers/esm/extends";
import { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';
export var GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = '__row_group_by_columns_group__';
export var ROW_GROUPING_STRATEGY = 'grouping-columns';
export var getRowGroupingFieldFromGroupingCriteria = function getRowGroupingFieldFromGroupingCriteria(groupingCriteria) {
  if (groupingCriteria === null) {
    return GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD;
  }

  return "__row_group_by_columns_group_".concat(groupingCriteria, "__");
};
export var getRowGroupingCriteriaFromGroupingField = function getRowGroupingCriteriaFromGroupingField(groupingColDefField) {
  var match = groupingColDefField.match(/^__row_group_by_columns_group_(.*)__$/);

  if (!match) {
    return null;
  }

  return match[1];
};
export var isGroupingColumn = function isGroupingColumn(field) {
  return field === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD || getRowGroupingCriteriaFromGroupingField(field) !== null;
};

/**
 * When filtering a group, we only want to filter according to the items related to this grouping column.
 */
var shouldApplyFilterItemOnGroup = function shouldApplyFilterItemOnGroup(item, node) {
  if (item.columnField === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD) {
    return true;
  }

  var groupingCriteriaField = getRowGroupingCriteriaFromGroupingField(item.columnField);
  return groupingCriteriaField === node.groupingField;
};
/**
 * A leaf is visible if it passed the filter
 * A group is visible if all the following criteria are met:
 * - One of its children is passing the filter
 * - It is passing the filter
 */


export var filterRowTreeFromGroupingColumns = function filterRowTreeFromGroupingColumns(params) {
  var rowTree = params.rowTree,
      isRowMatchingFilters = params.isRowMatchingFilters;
  var visibleRowsLookup = {};
  var filteredRowsLookup = {};
  var filteredDescendantCountLookup = {};

  var filterTreeNode = function filterTreeNode(node, areAncestorsPassingChildren, areAncestorsExpanded) {
    var _node$children, _node$children2;

    var isMatchingFilters;

    if (!isRowMatchingFilters) {
      isMatchingFilters = true;
    } else {
      var shouldApplyItem = node.isAutoGenerated ? function (item) {
        return shouldApplyFilterItemOnGroup(item, node);
      } : undefined;
      isMatchingFilters = isRowMatchingFilters(node.id, shouldApplyItem);
    }

    var filteredDescendantCount = 0;
    (_node$children = node.children) == null ? void 0 : _node$children.forEach(function (childId) {
      var childNode = rowTree[childId];
      var childSubTreeSize = filterTreeNode(childNode, areAncestorsPassingChildren && isMatchingFilters, areAncestorsExpanded && !!node.childrenExpanded);
      filteredDescendantCount += childSubTreeSize;
    });
    var shouldPassFilters;

    if (!areAncestorsPassingChildren) {
      shouldPassFilters = false;
    } else if ((_node$children2 = node.children) != null && _node$children2.length) {
      shouldPassFilters = isMatchingFilters && filteredDescendantCount > 0;
    } else {
      shouldPassFilters = isMatchingFilters;
    }

    visibleRowsLookup[node.id] = shouldPassFilters && areAncestorsExpanded;
    filteredRowsLookup[node.id] = shouldPassFilters;

    if (!shouldPassFilters) {
      return 0;
    }

    filteredDescendantCountLookup[node.id] = filteredDescendantCount;

    if (!node.children) {
      return filteredDescendantCount + 1;
    }

    return filteredDescendantCount;
  };

  var nodes = Object.values(rowTree);

  for (var i = 0; i < nodes.length; i += 1) {
    var node = nodes[i];

    if (node.depth === 0) {
      filterTreeNode(node, true, true);
    }
  }

  return {
    visibleRowsLookup: visibleRowsLookup,
    filteredRowsLookup: filteredRowsLookup,
    filteredDescendantCountLookup: filteredDescendantCountLookup
  };
};
export var getColDefOverrides = function getColDefOverrides(groupingColDefProp, fields) {
  if (typeof groupingColDefProp === 'function') {
    return groupingColDefProp({
      groupingName: ROW_GROUPING_STRATEGY,
      fields: fields
    });
  }

  return groupingColDefProp;
};
export var mergeStateWithRowGroupingModel = function mergeStateWithRowGroupingModel(rowGroupingModel) {
  return function (state) {
    return _extends({}, state, {
      rowGrouping: _extends({}, state.rowGrouping, {
        model: rowGroupingModel
      })
    });
  };
};
export var setStrategyAvailability = function setStrategyAvailability(apiRef, disableRowGrouping) {
  var isAvailable;

  if (disableRowGrouping) {
    isAvailable = function isAvailable() {
      return false;
    };
  } else {
    isAvailable = function isAvailable() {
      var rowGroupingSanitizedModel = gridRowGroupingSanitizedModelSelector(apiRef);
      return rowGroupingSanitizedModel.length > 0;
    };
  }

  apiRef.current.unstable_setStrategyAvailability('rowTree', ROW_GROUPING_STRATEGY, isAvailable);
};